<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
          integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="http://nitinhayaran.github.io/jRange/jquery.range.css">
    <link rel="stylesheet" href="../static/style.css">

    <title>How Does BERT Answer Questions?</title>

</head>

<body>
<div><h2 class="title">How Does BERT Answer Questions?</h2></div>
<p class="intro-text">Observe how BERT fine-tuned on QA tasks get to the right answers. This demo shows how the token
    representations change throughout the layers of BERT. It demonstrates the findings from our paper: <i>Betty van
        Aken, Benjamin Winter, Alexander LÃ¶ser and Felix Gers.
        <a href="https://openreview.net/pdf?id=SygMXE2vAE" target="_blank">How Does BERT Answer Questions? A Layer-Wise
            Analysis of Transformer Representations.</a> CIKM 2019.</i></p>

<div class="d-flex task-tab-wrapper">
    <div class="p-2 flex-fill task-tab task-tab-active" id="squadTab" onclick="switchToSquad()">SQuAD</div>
    <div class="p-2 flex-fill task-tab" id="hotpotTab" onclick="switchToHotpot()">HotpotQA</div>
    <div class="p-2 flex-fill task-tab task-tab-deactived" id="babiTab">bAbI QA</div>
</div>
<div class="question-form-container" align="center">
    <div class="row">
        <div class="col" align="left">

            <span class="form-label">Testset ID </span><span class="id-switcher-label" onclick="switchIdLeft()"><</span>
            <input type="text" id="id-input" name="id-input" class="id-switcher-input">
            <span class="id-switcher-label" onclick="switchIdRight()">></span><br>

            <label class="control-label form-label" for="question-textarea">Question</label>
            <textarea class="form-control form-textarea" id="question-textarea" name="question-textarea"
                      rows="2"></textarea>
            <label class="control-label form-label" for="ground-truth-answer">Ground Truth Answer</label>
            <input type="text" class="form-control" id="ground-truth-answer" name="ground-truth-answer">
            <label class="control-label form-label" for="predicted-answer">Predicted Answer</label>
            <input type="text" class="form-control" id="predicted-answer" name="predicted-answer" disabled>

        </div>
        <div class="col">
            <label class="control-label form-label" for="context-textarea">Context</label>
            <textarea class="form-control form-textarea" id="context-textarea" name="context-textarea"
                      rows="7"></textarea>
            <button class="form-button btn btn-info btn-block" onclick="requestPredictionAndVis()">Predict & Visualize
            </button>
        </div>
    </div>
</div>
</div>

<div class="slider-container">
    <div class="d-flex">
        <div class="flex-fill layer-label" align="left">0</div>
        <div class="flex-fill layer-label-large" align="center" id="layer_nr_label">Layer 0</div>
        <div class="flex-fill layer-label" align="right" id="layer_max">12</div>
    </div>
    <!--<span class="form-label layer-label" id="layer_nr_label">Layer 0</span>-->
    <input type="range" id="layer_nr_slider" min="0" max="12" step="1" value="0"/>
</div>
</div>

<div class="canvas-container">
    <canvas id="plot_canvas"></canvas>
</div>


<!-- JQuery Import - Placed at the end of the document so the pages load faster -->
<script src="https://code.jquery.com/jquery-3.4.1.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@2.8.0/dist/Chart.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@0.6.0"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@0.7.3"></script>

<script>

    var color = Chart.helpers.color;

    var fontDefault = {
        size: 12,
        weight: 'normal'
    };
    var fontBold = {
        weight: 'bold'
    };
    var fontHighlighted = {
        size: 14,
        weight: 'bold'
    };

    var scatterChartData = {
        datasets: [{
            pointBackgroundColor: [],
            pointBorderColor: [],
            data: [],
            datalabels: {
                font: function (context) {
                    var ind = context.dataIndex;

                    // highlight when token belongs to answer or question
                    if ("token_indices" in tokenInfo) {
                        if (isIn(ind, [tokenInfo.token_indices.answer.start, tokenInfo.token_indices.answer.end])) {
                            return fontHighlighted;
                        }
                        if (isIn(ind, [tokenInfo.token_indices.question.start, tokenInfo.token_indices.question.end])) {
                            return fontBold;
                        }
                    }

                    return fontDefault;
                }
            }
        }]
    };

    var layer_nr = 0;
    var hiddenStates = [];
    var scatterPlot;
    var tokenInfo = {};
    var currentDataset = 'squad';

    var datasets = {
        squad: {
            file: "../static/squad_examples.json",
            samples: null,
            currentIndex: 0,
            layer_nr: 12
        },
        hotpot: {
            file: "../static/hotpot_examples.json",
            samples: null,
            currentIndex: 0,
            layer_nr: 24
        }
    };


    function isIn(ind, range) {
        return ind >= range[0] && ind < range[1]
    }

    function findMinMax(data) {
        var minX = 1000000000;
        var maxX = -1000000000;
        var minY = 1000000000;
        var maxY = -1000000000;

        for (let i = 0; i < data.length; i++) {
            var point = data[i];
            if (point.x < minX) {
                minX = point.x
            }
            if (point.x > maxX) {
                maxX = point.x
            }
            if (point.y < minY) {
                minY = point.y
            }
            if (point.y > maxY) {
                maxY = point.y
            }
        }
        return [minX, maxX, minY, maxY]
    }

    function adjustSlider(nr_layers){
        $("#layer_nr_slider").attr("max", nr_layers);
        $("#layer_max").text(nr_layers);
    }

    function refreshData(newData, scatterPlot) {
        adjustSlider(datasets[currentDataset].layer_nr);

        scatterChartData.datasets[0].data = newData;

        var minMaxPoints = findMinMax(newData);

        // add padding to avoid clipping labels
        minMaxPoints[0] -= 1;
        minMaxPoints[1] += 3;
        minMaxPoints[2] -= 1;
        minMaxPoints[3] += 2;

        updateZoomAndPan(minMaxPoints[0], minMaxPoints[1], minMaxPoints[2], minMaxPoints[3]);

        if (tokenInfo !== {}) {
            formatPoints();
        }

        scatterPlot.update();
    }

    function updateZoomAndPan(minX, maxX, minY, maxY){
        var xAxis = scatterPlot.options.scales.xAxes[0];
        var yAxis = scatterPlot.options.scales.yAxes[0];

        xAxis.ticks.min = minX;
        xAxis.ticks.max = maxX;
        yAxis.ticks.min = minY;
        yAxis.ticks.max = maxY;

        scatterPlot.options.pan.rangeMin = { x: minX, y: minY};
        scatterPlot.options.pan.rangeMax = { x: maxX, y: maxY};

        scatterPlot.options.zoom.rangeMin = { x: minX, y: minY};
        scatterPlot.options.zoom.rangeMax = { x: maxX, y: maxY};
    }

    function insertSample(sample) {
        $('#id-input').val(sample.id);
        $('#question-textarea').val(sample.question);
        $('#ground-truth-answer').val(sample.answer);
        $('#predicted-answer').val("");
        $('#context-textarea').val(sample.context);
    }

    function parseText(component) {

        function trim(s) {
            return (s || '').replace(/^\s+|\s+$/g, '');
        }

        var text = component.val();
        text = encodeURIComponent(text);

        // Remove linebreaks from input
        text = text.replace(/\n/g, " ");

        // Remove quotes from input
        text = text.replace(/\"/g, "'");

        text = trim(text);

        return text;
    }

    function formatPoints() {

        for (let i = 0; i < scatterChartData.datasets[0].data.length; i++) {

            if (isIn(i, [tokenInfo.token_indices.question.start, tokenInfo.token_indices.question.end])) {

                scatterChartData.datasets[0].pointBackgroundColor[i] = color('blue').alpha(1).rgbString();
                scatterChartData.datasets[0].pointBorderColor[i] = 'blue';
            }
            else if (isIn(i, [tokenInfo.token_indices.answer.start, tokenInfo.token_indices.answer.end])) {

                scatterChartData.datasets[0].pointBackgroundColor[i] = color('purple').alpha(1).rgbString();
                scatterChartData.datasets[0].pointBorderColor[i] = 'purple';
            }
            else {
                scatterChartData.datasets[0].pointBackgroundColor[i] = color('red').alpha(0.2).rgbString();
                scatterChartData.datasets[0].pointBorderColor[i] = 'red';
            }
        }
    }


    function processResult(data) {
        var predictedAnswer = data.prediction.text;

        $('#predicted-answer').val(predictedAnswer);

        hiddenStates = data.hidden_states;
        tokenInfo["token_indices"] = data.token_indices;

        refreshData(hiddenStates[layer_nr], scatterPlot);
    }

    function requestPredictionAndVis() {

        var sample = {};

        sample.id = parseText($('#id-input'));
        sample.question = parseText($('#question-textarea'));
        sample.context = parseText($('#context-textarea'));
        sample.answer = parseText($('#ground-truth-answer'));

        var data = {};
        data.sample = sample;
        data.model = currentDataset;

        $.ajax({
            url: '/visbert/predict',
            type: 'post',
            data: JSON.stringify(data),
            headers: {
                'Content-Type': 'application/json'
            },
            dataType: 'json',
            success: function (data) {
                processResult(data);
            }
        });
    }

    function loadSamples() {
        var dataset = datasets[currentDataset];

        if(dataset.samples === null){
            $.getJSON(dataset.file, function (json) {
                dataset.samples = json;
                dataset.currentIndex = Math.floor(Math.random() * dataset.samples.length);

                insertSample(dataset.samples[dataset.currentIndex]);
            });
        } else {
            insertSample(dataset.samples[dataset.currentIndex]);
        }
    }

    function switchToHotpot(){
        currentDataset = 'hotpot';
        loadSamples();

        $('#hotpotTab').addClass('task-tab-active');
        $('#squadTab').removeClass('task-tab-active');
        $('#babiTab').removeClass('task-tab-active');
    }

    function switchToSquad(){
        currentDataset = 'squad';
        loadSamples();

        $('#squadTab').addClass('task-tab-active');
        $('#hotpotTab').removeClass('task-tab-active');
        $('#babiTab').removeClass('task-tab-active');
    }

    function switchIdLeft() {
        var dataset = datasets[currentDataset];

        if (dataset.currentIndex > 0) {
            dataset.currentIndex = dataset.currentIndex - 1;
            insertSample(dataset.samples[dataset.currentIndex]);
        }
    }

    function switchIdRight() {
        var dataset = datasets[currentDataset];

        if (dataset.currentIndex < dataset.samples.length - 1) {
            dataset.currentIndex = dataset.currentIndex + 1;
            insertSample(dataset.samples[dataset.currentIndex]);
        }
    }

    function refreshLayerNr(new_layer_nr) {
        layer_nr = new_layer_nr;

        $("#layer_nr_label").text("Layer " + layer_nr);
    }

    $(document).ready(function () {

        $("#layer_nr_slider").val(0);
        loadSamples('squad');

        var ctx = $('#plot_canvas');
        scatterPlot = Chart.Scatter(ctx, {
            data: scatterChartData,
            options: {
                pan: {
                    enabled: true,
                    mode: "xy",
                    speed: 0.01,
                    // threshold: 10,
                    rangeMin: {
                        x: 0,
                        y: 0
                    },
                    rangeMax: {
                        x: 0,
                        y: 0
                    }
                },
                zoom: {
                    enabled: true,
                    drag: false,
                    mode: "xy",
                    speed: 0.02,
                    rangeMin: {
                        x: 0,
                        y: 0
                    },
                    rangeMax: {
                        x: 10,
                        y: 10
                    }
                },
                scales: {
                    xAxes: [{
                        ticks: {
                            maxRotation: 0,
                            precision: 0,
                            min: 0,
                            max:10,
                            callback: function(value, index, values) {
                                return Math.round(value);
                            }
                        }
                    }],
                    yAxes: [{
                        ticks: {
                            maxRotation: 0,
                            precision: 0,
                            min: 0,
                            max:10,
                            callback: function(value, index, values) {
                                return Math.round(value);
                            }
                        }
                    }]
                },
                tooltips: {
                    callbacks: {
                        label: function (tooltipItem, data) {
                            return data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index].label;
                        }
                    }
                },
                plugins: {
                    datalabels: {
                        anchor: 'end',
                        align: 'right',
                        color: 'grey',
                        offset: 8,
                        padding: 0,
                        clamp: true
                    },
                    legend: false,
                    title: false
                }
            }
        });

        $("#layer_nr_slider").on("input change", function () {
            var new_layer_nr = $(this).val();

            if (new_layer_nr !== layer_nr) {
                refreshLayerNr(new_layer_nr);

                if (hiddenStates.length > layer_nr) {
                    refreshData(hiddenStates[layer_nr], scatterPlot, null);
                }
            }
        });

    });
</script>
</body>

</html>